import { TitleEntry } from './types';
import { plainBody, formatTodo as plainFormat } from './summaryFormatters/plain';
import { tableBody, formatTodo as tableFormat } from './summaryFormatters/table';
import { diaryBody, formatTodo as diaryFormat } from './summaryFormatters/diary';

// To add a new summary format, create a new file in src/summaryFormatters/
// (I suggest copying from table body)
// Import it here and add a corresponding definition below.
// The title is what will appear in the settings menu
export const summaries = {
	plain: {
		title: 'Category/Notebook List',
		func: plainBody,
		format: plainFormat,
	},
	table: {
		title: 'Table',
		func: tableBody,
		format: tableFormat,
	},
	diary: {
		title: 'Notebook List',
		func: diaryBody,
		format: diaryFormat,
	},
}

// To add a new regex simple define one below
// The title is what will appear in the settings menu
// The regex is what will identify a todo line
// The query is what will identify a note with a todo in it (Joplin search syntax)
// The category is a function that extracts the category from the todo
// The date is a function that extracts the date from the todo
// The tags is a function that extracts the tags from the todo
// The msg is a function that extracts the message from the todo
// The toggle is an object that containes the [un]completed state of a todo
// The completed_query is what will identify a note with a completed todo (Joplin search syntax)
// The completed_regex is what will identify a line as completed
// The scrollToText will be used the the scrollToText command
export const regexes = {
	list: {
		title: 'Metalist Style',
		// change to find completed todo
		regex: /(^\s*- \[[ Xx]\]\s.*(?<=\s)(?:(@[^\s]+)|(\/\/[^\s]+)|(\+[^\s]+))(?:[^\n]*)?$)((?:\n[^\S\n]+.+$)*)/gm,
		query: '/"- [ ]"',
		category: (todo: string[]) => {
			const result = todo[1].match(/(?<=\s@)([^\s]+)/);
			return result ? result[0] : '';
		},
		date: (todo: string[]) => {
			const result = todo[1].match(/(?<=\s\/\/)([^\s]+)/);
			return result ? result[0] : '';
		},
		tags: (todo: string[]) => {
			// the /g is important to get multiple results instead of a single match
			const result = todo[1].match(/(?<=\s\+)[^\s]+/g);
			return result ? result : [];
		},
		msg: (todo: string[]) => {
			let result = todo[1].split(/\s@[^\s]+/).join('');
			result = result.split(/\s\/\/[^\s]+/).join('');
			result = result.split(/\s\+[^\s]+/).join('');
			result = result.split(/- \[[ Xx]\]/).join('');
			return result.trim();
		},
		description: (todo: string[]) => {
			return todo.length > 5 ? todo[5] : '';
		},
		toggle: { open: '- [ ]', closed: '- [x]' },
		completed_query: '/"- [x]"',
		completed: (todo: string[]) => {
			const regex = /^\s*- \[[Xx]\]\s.*$/;
			return regex.test(todo[1]);
		},
		scrollToText: (todo: string[]) => ({
			// Remove the leading whitespace and the '- ' it will be added by the scrollToText function
			text: todo[1].trim().slice(2),
			element: 'ul'
		}),
	},
	link: {
		title: 'Link Style',
		regex: /\[((?:TODO)|(?:DONE))\]\((.*?)\)([^\n]+)$/gmi,
		query: '/"[TODO]"',
		category: (todo: string[]) => { return todo[1]; },
		date: (todo: string[]) => { return todo[2]; },
		tags: (todo: string[]) => { return []; },
		msg: (todo: string[]) => { return todo[3]; },
		description: (todo: string[]) => { return '' },
		toggle: { open: '[TODO]', closed: '[DONE]' },
		completed_query: '/"[DONE]"',
		completed: (todo: string[]) => {
			const regex = /\[DONE\]\(.*?\)([^\n]+)$/;
			return regex.test(todo[0]);
		},
		scrollToText: (todo: string[]) => ({}),
	},
	plain: {
		title: 'List Style',
		regex: /(^\s*- \[[ Xx]\] ()()([^\n]*)$)((?:\n[^\S\n]+[-*+] (?!\[[ x]\]).+$)*)/gm,
		query: '/"- [ ]"',
		category: (todo: string[]) => {
			const result = regexes.list.category(todo);
			return result || 'Unassigned';
		},
		date: (todo: string[]) => {
			return regexes.list.date(todo);
		},
		tags: (todo: string[]) => {
			return regexes.list.tags(todo);
		},
		msg: (todo: string[]) => {
			return regexes.list.msg(todo);
		},
		description: (todo: string[]) => {
			return todo.length > 5 ? todo[5] : '';
		},
		toggle: { open: '- [ ]', closed: '- [x]' },
		completed_query: '/"- [x]"',
		completed: (todo: string[]) => {
			const regex = /^\s*- \[[Xx]\]\s.*$/;
			return regex.test(todo[1]);
		},
		scrollToText: (todo: string[]) => ({
			// Remove the leading '- ' it will be added by the scrollToText function
			text: todo[1].slice(2),
			element: 'ul'
		}),
	},
}

// Below here is the autogenerated titles that will be used by the settings

function toSettingsTitles(tbl: Record<string, TitleEntry>): Record<string, string> {
	const titles = {};
	for (const [key, value] of Object.entries(tbl)) {
		titles[key] = value.title;
	}

	return titles;
}

export const regexTitles = toSettingsTitles(regexes);
export const summaryTitles = toSettingsTitles(summaries);
